{"version":3,"file":"components.js","sourceRoot":"","sources":["../../../src/lib/serialization/components.ts"],"names":[],"mappings":";;AAAA,sCAA6C;AAC7C,oCAA6C;AAgB7C,MAAsB,mBAAuB,SAAQ,yBAA6B;IA6ChF,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IACtC,CAAC;;AAzCM,4BAAQ,GAAG,CAAC,CAAC;AANtB,kDAqDC;AAED,MAAsB,6BAAoD,SAAQ,mBAAsB;IAAxG;;QASE,yBAAoB,GAAG,mBAAU,CAAC;IACpC,CAAC;IALC,cAAc,CAAC,QAAiB;QAC9B,OAAO,QAAQ,YAAY,mBAAU,CAAC;IACxC,CAAC;CAGF;AAVD,sEAUC;AAED,MAAsB,uBAAwC,SAAQ,mBAAsB;IAA5F;;QASE,yBAAoB,GAAG,aAAI,CAAC;IAC9B,CAAC;IALC,cAAc,CAAC,QAAiB;QAC9B,OAAO,QAAQ,YAAY,aAAI,CAAC;IAClC,CAAC;CAGF;AAVD,0DAUC","sourcesContent":["import { Reflection, Type } from '../models';\r\nimport { AbstractComponent } from '../utils';\r\n\r\nimport { Serializer } from './serializer';\r\n\r\n/**\r\n * Represents Serializer plugin component.\r\n *\r\n * Like [[Converter]] plugins each [[Serializer]] plugin defines a predicate that instructs if an\r\n * object can be serialized by it, this is done dynamically at runtime via a `supports` method.\r\n *\r\n * Additionally, each [[Serializer]] plugin must defines a predicate that instructs the group\r\n * it belongs to.\r\n *\r\n * Grouping serializers is required due to performance, we don't need to check all the reflection\r\n * serializers when we are looking for type (or any other) serializers.\r\n */\r\nexport abstract class SerializerComponent<T> extends AbstractComponent<Serializer> {\r\n\r\n  /**\r\n   * The priority this serializer should be executed with.\r\n   * A higher priority means the [[Serializer]] will be applied earlier.\r\n   */\r\n  static PRIORITY = 0;\r\n\r\n  /**\r\n   * A high-level predicate filtering which group this serializer belongs to.\r\n   * This is a high-level filter before the [[SerializerComponent.supports]] predicate filter.\r\n   *\r\n   * When the filter returns true the group identifier is taken from\r\n   * [[SerializerComponentType.serializeGroupSymbol]].\r\n   *\r\n   * For example, use the [[Reflection]] class class to group all reflection based serializers:\r\n   * ```typescript\r\n   * class ReflectionSerializer {\r\n   *  serializeGroup(instance) { return instance instanceof Reflection }\r\n   *  serializeGroupSymbol = Reflection;\r\n   * }\r\n   * ```\r\n   *\r\n   * Use the [[Type]] class to group all type based serializers:\r\n   * ```typescript\r\n   * class TypeSerializer {\r\n   *  serializeGroup(instance) { return instance instanceof Type }\r\n   *  serializeGroupSymbol = Type;\r\n   * }\r\n   * ```\r\n   *\r\n   * > When a serializer component extends a parent serializer component the SERIALIZE_GROUP\r\n   * and SERIALIZE_GROUP_SYMBOL are also inherited so child serializers of the same group do not\r\n   * need to declare a predicate nor a group.\r\n   */\r\n  abstract serializeGroup(instance: unknown): boolean;\r\n  /**\r\n   * The symbol representing the group this serializer belongs to.\r\n   */\r\n  abstract serializeGroupSymbol: any;\r\n\r\n  /**\r\n   * The priority this serializer should be executed with.\r\n   * A higher priority means the [[Serializer]] will be applied earlier.\r\n   */\r\n  get priority(): number {\r\n    return this.constructor['PRIORITY'];\r\n  }\r\n\r\n  abstract supports(item: unknown): boolean;\r\n\r\n  abstract toObject(item: T, obj?: any): any;\r\n\r\n}\r\n\r\nexport abstract class ReflectionSerializerComponent<T extends Reflection> extends SerializerComponent<T> {\r\n\r\n  /**\r\n   * Filter for instances of [[Reflection]]\r\n   */\r\n  serializeGroup(instance: unknown): boolean {\r\n    return instance instanceof Reflection;\r\n  }\r\n\r\n  serializeGroupSymbol = Reflection;\r\n}\r\n\r\nexport abstract class TypeSerializerComponent<T extends Type> extends SerializerComponent<T> {\r\n\r\n  /**\r\n   * Filter for instances of [[Type]]\r\n   */\r\n  serializeGroup(instance: unknown): boolean {\r\n    return instance instanceof Type;\r\n  }\r\n\r\n  serializeGroupSymbol = Type;\r\n}\r\n"]}