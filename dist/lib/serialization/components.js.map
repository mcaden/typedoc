{"version":3,"file":"components.js","sourceRoot":"","sources":["../../../src/lib/serialization/components.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,oCAA6C;AAC7C,kCAA6C;AAsB7C;IAAqD,uCAA6B;IAAlF;;IAqDA,CAAC;IARC,sBAAI,yCAAQ;aAAZ;YACE,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QACtC,CAAC;;;OAAA;IAzCM,4BAAQ,GAAG,CAAC,CAAC;IA+CtB,0BAAC;CAAA,AArDD,CAAqD,yBAAiB,GAqDrE;AArDqB,kDAAmB;AAuDzC;IAAkF,iDAAsB;IAAxG;QAAA,qEAgBC;QANC,oBAAc,GAAG,6BAA6B,CAAC,cAAc,CAAC;QAC9D,0BAAoB,GAAG,mBAAU,CAAC;;IAKpC,CAAC;IAXkB,4CAAc,GAA/B,UAAgC,QAAa;QAC3C,OAAO,QAAQ,YAAY,mBAAU,CAAC;IACxC,CAAC;IASH,oCAAC;AAAD,CAAC,AAhBD,CAAkF,mBAAmB,GAgBpG;AAhBqB,sEAA6B;AAkBnD;IAAsE,2CAAsB;IAA5F;QAAA,qEAgBC;QANC,oBAAc,GAAG,uBAAuB,CAAC,cAAc,CAAC;QACxD,0BAAoB,GAAG,aAAI,CAAC;;IAK9B,CAAC;IAXkB,sCAAc,GAA/B,UAAgC,QAAa;QAC3C,OAAO,QAAQ,YAAY,aAAI,CAAC;IAClC,CAAC;IASH,8BAAC;AAAD,CAAC,AAhBD,CAAsE,mBAAmB,GAgBxF;AAhBqB,0DAAuB","sourcesContent":["import { Reflection, Type } from '../models';\r\nimport { AbstractComponent } from '../utils';\r\n\r\nimport { Serializer } from './serializer';\r\n\r\n/**\r\n * Represents Serializer plugin component.\r\n *\r\n * Like [[Converter]] plugins each [[Serializer]] plugin defines a predicate that instructs if an\r\n * object can be serialized by it, this is done dynamically at runtime via a `supports` method.\r\n *\r\n * Additionally, each [[Serializer]] plugin must defines a predicate that instructs the group\r\n * it belongs to.\r\n *\r\n * Grouping serializers is required due to performance, we don't need to check all the reflection\r\n * serializers when we are looking for type (or any other) serializers.\r\n *\r\n * [[Serializer]] will compare the function referenced in `serializeGroup` for each serializer\r\n * component instance, this is why, when extending [[SerializerComponent]], it is recommended to\r\n * reference `serializeGroup` to an existing function instead of creating a new function on for\r\n * every new plugin. This will ensure maximum performance.\r\n * > It is also possible to set a get accessor in the prototype to return the same function.\r\n */\r\nexport abstract class SerializerComponent<T> extends AbstractComponent<Serializer> {\r\n\r\n  /**\r\n   * The priority this serializer should be executed with.\r\n   * A higher priority means the [[Serializer]] will be applied earlier.\r\n   */\r\n  static PRIORITY = 0;\r\n\r\n  /**\r\n   * A high-level predicate filtering which group this serializer belongs to.\r\n   * This is a high-level filter before the [[SerializerComponent.supports]] predicate filter.\r\n   *\r\n   * When the filter returns true the group identifier is taken from\r\n   * [[SerializerComponentType.serializeGroupSymbol]].\r\n   *\r\n   * For example, use the [[Reflection]] class class to group all reflection based serializers:\r\n   * ```typescript\r\n   * class ReflectionSerializer {\r\n   *  serializeGroup = instance => instance instanceof Reflection ? Reflection : undefined;\r\n   *  serializeGroupSymbol = Reflection;\r\n   * }\r\n   * ```\r\n   *\r\n   * Use the [[Type]] class to group all type based serializers:\r\n   * ```typescript\r\n   * class TypeSerializer {\r\n   *  serializeGroup = instance => instance instanceof Type ? Type : undefined;\r\n   *  serializeGroupSymbol = Type;\r\n   * }\r\n   * ```\r\n   *\r\n   * > When a serializer component extends a parent serializer component the SERIALIZE_GROUP\r\n   * and SERIALIZE_GROUP_SYMBOL are also inherited so child serializers of the same group does not\r\n   * need to declare a predicate nor a group.\r\n   */\r\n  abstract serializeGroup: (instance: boolean) => boolean;\r\n  /**\r\n   * The symbol representing the group this serializer belongs to.\r\n   */\r\n  abstract serializeGroupSymbol: any;\r\n\r\n  /**\r\n   * The priority this serializer should be executed with.\r\n   * A higher priority means the [[Serializer]] will be applied earlier.\r\n   */\r\n  get priority(): number {\r\n    return this.constructor['PRIORITY'];\r\n  }\r\n\r\n  supports: (item: T) => boolean;\r\n\r\n  abstract toObject(item: T, obj?: any): any;\r\n\r\n}\r\n\r\nexport abstract class ReflectionSerializerComponent<T extends Reflection> extends SerializerComponent<T> {\r\n\r\n  /**\r\n   * Filter for instances of [[Reflection]]\r\n   */\r\n  protected static serializeGroup(instance: any): boolean {\r\n    return instance instanceof Reflection;\r\n  }\r\n\r\n  // use same fn for every instance\r\n  serializeGroup = ReflectionSerializerComponent.serializeGroup;\r\n  serializeGroupSymbol = Reflection;\r\n\r\n  supports: (reflection: T) => boolean;\r\n\r\n  abstract toObject(reflection: T, obj?: any): any;\r\n}\r\n\r\nexport abstract class TypeSerializerComponent<T extends Type> extends SerializerComponent<T> {\r\n\r\n  /**\r\n   * Filter for instances of [[Type]]\r\n   */\r\n  protected static serializeGroup(instance: any): boolean {\r\n    return instance instanceof Type;\r\n  }\r\n\r\n  // use same fn for every instance\r\n  serializeGroup = TypeSerializerComponent.serializeGroup;\r\n  serializeGroupSymbol = Type;\r\n\r\n  supports: (type: T) => boolean;\r\n\r\n  abstract toObject(type: T, obj?: any): any;\r\n}\r\n"]}