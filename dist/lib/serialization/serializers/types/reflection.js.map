{"version":3,"file":"reflection.js","sourceRoot":"","sources":["../../../../../src/lib/serialization/serializers/types/reflection.ts"],"names":[],"mappings":";;;;;;;;AAAA,wDAAqD;AACrD,4CAAwE;AAExE,iDAA2D;AAG3D,IAAa,wBAAwB,GAArC,MAAa,wBAAyB,SAAQ,oCAAuC;IAInF,QAAQ,CAAC,CAAU;QACjB,OAAO,CAAC,YAAY,uBAAc,CAAC;IACrC,CAAC;IAED,QAAQ,CAAC,SAAyB,EAAE,GAAS;QAC3C,GAAG,GAAG,GAAG,IAAI,EAAE,CAAC;QAEhB,IAAI,SAAS,CAAC,WAAW,EAAE;YAOzB,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,WAAW,EAAE;gBAG9C,GAAG,CAAC,WAAW,GAAG,EAAE,EAAE,EAAE,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;aACpD;iBAAM;gBAEL,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;gBAGzC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;aAC9D;YAGD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;SAC9B;QAED,OAAO,GAAG,CAAC;IACb,CAAC;CACF,CAAA;AApCY,wBAAwB;IADpC,qBAAS,CAAC,EAAC,IAAI,EAAE,4BAA4B,EAAC,CAAC;GACnC,wBAAwB,CAoCpC;AApCY,4DAAwB","sourcesContent":["import { Component } from '../../../utils/component';\r\nimport { DeclarationReflection, ReflectionType } from '../../../models';\r\n\r\nimport { TypeSerializerComponent } from '../../components';\r\n\r\n@Component({name: 'serializer:reflection-type'})\r\nexport class ReflectionTypeSerializer extends TypeSerializerComponent<ReflectionType> {\r\n\r\n  private declaration?: DeclarationReflection;\r\n\r\n  supports(t: unknown) {\r\n    return t instanceof ReflectionType;\r\n  }\r\n\r\n  toObject(reference: ReflectionType, obj?: any): any {\r\n    obj = obj || {};\r\n\r\n    if (reference.declaration) {\r\n\r\n      // Because `DeclarationReflection` has reference to multiple types objectifying a declaration\r\n      // on a type might fall into a loop trap (cyclic dependency).\r\n      // The TypeDoc code does not apply logic that can create this scenario but a 3rd party plugin\r\n      // might do that unintentionally so a protection is in place.\r\n\r\n      if (this.declaration === reference.declaration) {\r\n        // if we're here it means that the reference type is rendered for the 2nd time\r\n        // by the declaration it is referencing, we will render a pointer-only declaration.\r\n        obj.declaration = { id: reference.declaration.id };\r\n      } else {\r\n        // mark this declaration to trap a loop\r\n        this.declaration = reference.declaration;\r\n\r\n        // objectify the declaration\r\n        obj.declaration = this.owner.toObject(reference.declaration);\r\n      }\r\n\r\n      // no more declaration rendering, remove marker.\r\n      this.declaration = undefined;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n}\r\n"]}