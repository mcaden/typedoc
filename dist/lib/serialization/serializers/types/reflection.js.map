{"version":3,"file":"reflection.js","sourceRoot":"","sources":["../../../../../src/lib/serialization/serializers/types/reflection.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,sDAAqD;AACrD,0CAAwE;AAExE,+CAA2D;AAG3D;IAA8C,4CAAuC;IAArF;;IAqCA,CAAC;IAjCC,6CAAU,GAAV;QACE,iBAAM,UAAU,WAAE,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,UAAC,CAAiB,IAAK,OAAA,CAAC,YAAY,uBAAc,EAA3B,CAA2B,CAAC;IACrE,CAAC;IAED,2CAAQ,GAAR,UAAS,SAAyB,EAAE,GAAS;QAC3C,GAAG,GAAG,GAAG,IAAI,EAAE,CAAC;QAEhB,IAAI,SAAS,CAAC,WAAW,EAAE;YAOzB,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC,WAAW,EAAE;gBAG9C,GAAG,CAAC,WAAW,GAAG,EAAE,EAAE,EAAE,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;aACpD;iBAAM;gBAEL,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;gBAGzC,GAAG,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;aAC9D;YAGD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;SAC9B;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IApCU,wBAAwB;QADpC,qBAAS,CAAC,EAAC,IAAI,EAAE,4BAA4B,EAAC,CAAC;OACnC,wBAAwB,CAqCpC;IAAD,+BAAC;CAAA,AArCD,CAA8C,oCAAuB,GAqCpE;AArCY,4DAAwB","sourcesContent":["import { Component } from '../../../utils/component';\r\nimport { DeclarationReflection, ReflectionType } from '../../../models';\r\n\r\nimport { TypeSerializerComponent } from '../../components';\r\n\r\n@Component({name: 'serializer:reflection-type'})\r\nexport class ReflectionTypeSerializer extends TypeSerializerComponent<ReflectionType> {\r\n\r\n  private declaration: DeclarationReflection;\r\n\r\n  initialize(): void {\r\n    super.initialize();\r\n    this.supports = (t: ReflectionType) => t instanceof ReflectionType;\r\n  }\r\n\r\n  toObject(reference: ReflectionType, obj?: any): any {\r\n    obj = obj || {};\r\n\r\n    if (reference.declaration) {\r\n\r\n      // Because `DeclarationReflection` has reference to multiple types objectifying a declaration\r\n      // on a type might fall into a loop trap (cyclic dependency).\r\n      // The TypeDoc code does not apply logic that can create this scenario but a 3rd party plugin\r\n      // might do that unintentionally so a protection is in place.\r\n\r\n      if (this.declaration === reference.declaration) {\r\n        // if we're here it means that the reference type is rendered for the 2nd time\r\n        // by the declaration it is referencing, we will render a pointer-only declaration.\r\n        obj.declaration = { id: reference.declaration.id };\r\n      } else {\r\n        // mark this declaration to trap a loop\r\n        this.declaration = reference.declaration;\r\n\r\n        // objectify the declaration\r\n        obj.declaration = this.owner.toObject(reference.declaration);\r\n      }\r\n\r\n      // no more declaration rendering, remove marker.\r\n      this.declaration = undefined;\r\n    }\r\n\r\n    return obj;\r\n  }\r\n}\r\n"]}