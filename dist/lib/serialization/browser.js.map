{"version":3,"file":"browser.js","sourceRoot":"","sources":["../../../src/lib/serialization/browser.ts"],"names":[],"mappings":"","sourcesContent":["/**\r\n * Shared serialized symbols\r\n * The shared symbols can be used in node or in a browser web application.\r\n *\r\n * There are 2 types of symbols:\r\n *   - Object\r\n *   - Container\r\n *\r\n * ## Object\r\n * Object symbols (XXXObject) represents the final structure of a JSON object after it was\r\n * serialized by the native typedoc serializers. It is a type composition of Container symbols.\r\n *\r\n * ## Container\r\n * Container symbols (XXXContainer) are partial symbols used to compose an Object symbol.\r\n *\r\n * ## Object vs Container symbols\r\n * While Container symbols might look redundant they are not, when an external serialization plugin\r\n * is used it will, most likely, alter the structure of the output, the plugin can then use the\r\n * Container symbols to expose custom Object symbols with minimal effort.\r\n */\r\n\r\nexport interface ReflectionContainer {\r\n  id: number;\r\n  name: string;\r\n  kind: number;\r\n  kindString: string;\r\n  flags: ReflectionFlagsObject;\r\n  originalName?: string;\r\n}\r\n\r\nexport interface DefaultValueContainer {\r\n  defaultValue: string;\r\n}\r\n\r\nexport interface TypeContainer  {\r\n  type: TypeObject;\r\n}\r\n\r\nexport interface TypeParameterContainer {\r\n  typeParameters: TypeContainer[];\r\n}\r\n\r\nexport interface DecoratesContainer {\r\n  decorates: TypeObject[];\r\n}\r\n\r\nexport interface DecoratorsContainer<T> {\r\n  decorators: T[];\r\n}\r\n\r\nexport interface SourceReferenceContainer<T> {\r\n  sources: T[];\r\n}\r\n\r\nexport interface GroupsContainer<T> {\r\n  groups: T[];\r\n}\r\n\r\nexport interface ContainerReflectionContainer<TChildren> {\r\n  children: TChildren[];\r\n}\r\n\r\nexport interface CommentContainer<TComment> {\r\n  comment: TComment;\r\n}\r\n\r\nexport interface SignatureReflectionContainer<TParameters> {\r\n  /**\r\n   * A type that points to the reflection that has been overwritten by this reflection.\r\n   *\r\n   * Applies to interface and class members.\r\n   */\r\n  overwrites?: TypeObject;\r\n\r\n  /**\r\n   * A type that points to the reflection this reflection has been inherited from.\r\n   *\r\n   * Applies to interface and class members.\r\n   */\r\n  inheritedFrom?: TypeObject;\r\n\r\n  /**\r\n   * A type that points to the reflection this reflection is the implementation of.\r\n   *\r\n   * Applies to class members.\r\n   */\r\n  implementationOf?: TypeObject;\r\n\r\n  parameters?: TParameters[];\r\n}\r\n\r\nexport interface DeclarationReflectionContainer<T> {\r\n  /**\r\n   * A list of call signatures attached to this declaration.\r\n   *\r\n   * TypeDoc creates one declaration per function that may contain ore or more\r\n   * signature reflections.\r\n   */\r\n  signatures?: T[];\r\n\r\n  /**\r\n   * The index signature of this declaration.\r\n   */\r\n  indexSignature?: T[];\r\n\r\n  /**\r\n   * The get signature of this declaration.\r\n   */\r\n  getSignature?: T[];\r\n\r\n  /**\r\n   * The set signature of this declaration.\r\n   */\r\n  setSignature?: T[];\r\n\r\n  /**\r\n   * A list of all types this reflection extends (e.g. the parent classes).\r\n   */\r\n  extendedTypes?: TypeObject[];\r\n\r\n  /**\r\n   * A list of all types that extend this reflection (e.g. the subclasses).\r\n   */\r\n  extendedBy?: TypeObject[];\r\n\r\n  /**\r\n   * A list of all types this reflection implements.\r\n   */\r\n  implementedTypes?: TypeObject[];\r\n\r\n  /**\r\n   * A list of all types that implement this reflection.\r\n   */\r\n  implementedBy?: TypeObject[];\r\n\r\n}\r\n\r\nexport interface ReflectionObject extends ReflectionContainer,\r\n                                          Partial<CommentContainer<CommentObject>>,\r\n                                          Partial<DecoratesContainer>,\r\n                                          Partial<DecoratorsContainer<DecoratorObject>> { }\r\n\r\nexport interface ParameterReflectionObject extends  ReflectionObject,\r\n                                                    TypeContainer,\r\n                                                    DefaultValueContainer {}\r\n\r\nexport interface ContainerReflectionObject extends  ReflectionObject,\r\n                                                    Partial<SourceReferenceContainer<SourceReferenceObject>>,\r\n                                                    Partial<GroupsContainer<ReflectionGroupObject>>,\r\n                                                    ContainerReflectionContainer<ReflectionObject> {}\r\n\r\nexport interface DeclarationReflectionObject extends  ContainerReflectionObject,\r\n                                                      DefaultValueContainer,\r\n                                                      Partial<TypeContainer>,\r\n                                                      Partial<TypeParameterContainer>,\r\n                                                      Partial<SignatureReflectionContainer<ParameterReflectionObject>>,\r\n                                                      DeclarationReflectionContainer<SignatureReflectionObject> {}\r\n\r\nexport interface SignatureReflectionObject extends  ReflectionObject,\r\n                                                    Partial<SignatureReflectionContainer<ParameterReflectionObject>>,\r\n                                                    Partial<TypeContainer>,\r\n                                                    Partial<TypeParameterContainer> { }\r\n\r\nexport interface CommentObject {\r\n  shortText?: string;\r\n  text?: string;\r\n  returns?: string;\r\n  tags?: CommentTagObject[];\r\n}\r\n\r\nexport interface CommentTagObject {\r\n  tag: string;\r\n  text: string;\r\n  param?: string;\r\n}\r\n\r\nexport interface DecoratorObject {\r\n  /**\r\n   * The name of the decorator being applied.\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * The type declaring the decorator.\r\n   * Usually a ReferenceType instance pointing to the decorator function.\r\n   */\r\n  type?: TypeObject;\r\n\r\n  /**\r\n   * A named map of arguments the decorator is applied with.\r\n   */\r\n  arguments?: any;\r\n}\r\n\r\nexport interface ProjectReflectionObject extends ContainerReflectionObject { }\r\n\r\nexport interface SourceReferenceObject {\r\n  fileName: string;\r\n  line: number;\r\n  character: number;\r\n}\r\n\r\nexport interface TypeObject {\r\n\r\n  /**\r\n   * The type name identifier.\r\n   */\r\n  type: 'void' | 'array' | 'intersection' | 'intrinsic' | 'reference' | 'reflection' | 'stringLiteral' | 'tuple' | 'typeParameter' | 'union' | 'unknown' | string;\r\n\r\n  // array\r\n  /**\r\n   * For Array type only, The type (T) of the array's elements.\r\n   */\r\n  elementType?: TypeObject;\r\n\r\n  // intersection\r\n  /**\r\n   * For intersection type only, the types the union consists of.\r\n   * For union type only, the types the union consists of.\r\n   */\r\n  types?: TypeObject[];\r\n\r\n  // intrinsic, reference, typeParameter, unknown\r\n  /**\r\n   * For intrinsic type only, The name of the intrinsic type like `string` or `boolean`.\r\n   *\r\n   * For reference type only,  The name of the referenced type.\r\n   * If the symbol cannot be found cause it's not part of the documentation this\r\n   * can be used to represent the type.\r\n   *\r\n   * For typeParameter type only, the name of the type.\r\n   *\r\n   * For unknown type only, the name of the type.\r\n   */\r\n  name?: 'Object' | 'string' | 'number' | 'boolean' | 'this' | string;\r\n\r\n  // reference\r\n  /**\r\n   * The reflection id for this type\r\n   */\r\n  id?: number;\r\n\r\n  /**\r\n   * For reference type only, The type arguments of this reference.\r\n   */\r\n  typeArguments?: TypeObject[];\r\n\r\n  // reflection\r\n  /**\r\n   * For reflection type only, The reflection of the type.\r\n   */\r\n  declaration?: ReflectionObject;\r\n\r\n  // stringLiteral\r\n  /**\r\n   * For stringLiteral type only, The string literal value.\r\n   */\r\n  value?: string;\r\n\r\n  // tuple\r\n  /**\r\n   * For tuple type only, The ordered type elements of the tuple type.\r\n   */\r\n  elements?: TypeObject[];\r\n\r\n  // typeParameter\r\n  /**\r\n   * For typeParameter type only, The constraint type for the generic type.\r\n   */\r\n  constraint?: TypeObject;\r\n}\r\n\r\nexport interface ReflectionGroupObject {\r\n  /**\r\n   * The title, a string representation of the typescript kind, of this group.\r\n   */\r\n  title: string;\r\n\r\n  /**\r\n   * The original typescript kind of the children of this group.\r\n   */\r\n  kind: number;\r\n\r\n  /**\r\n   * A list of reflection id's for this group.\r\n   */\r\n  children?: number[];\r\n}\r\n\r\nexport interface ReflectionFlagsObject {\r\n  /**\r\n   * Is this a private member?\r\n   */\r\n  isPrivate?: boolean;\r\n\r\n  /**\r\n   * Is this a protected member?\r\n   */\r\n  isProtected?: boolean;\r\n\r\n  /**\r\n   * Is this a public member?\r\n   */\r\n  isPublic?: boolean;\r\n\r\n  /**\r\n   * Is this a static member?\r\n   */\r\n  isStatic?: boolean;\r\n\r\n  /**\r\n   * Is this member exported?\r\n   */\r\n  isExported?: boolean;\r\n\r\n  /**\r\n   * Is this a declaration from an external document?\r\n   */\r\n  isExternal?: boolean;\r\n\r\n  /**\r\n   * Whether this reflection is an optional component or not.\r\n   *\r\n   * Applies to function parameters and object members.\r\n   */\r\n  isOptional?: boolean;\r\n\r\n  /**\r\n   * Whether it's a rest parameter, like `foo(...params);`.\r\n   */\r\n  isRest?: boolean;\r\n\r\n  /**\r\n   *\r\n   */\r\n  hasExportAssignment?: boolean;\r\n\r\n  isConstructorProperty?: boolean;\r\n}\r\n"]}