{"version":3,"file":"signature.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/signature.ts"],"names":[],"mappings":";;AAAA,iCAAiC;AAEjC,8CAA2H;AAE3H,4CAAyC;AACzC,2CAA8C;AAC9C,2CAAkD;AAWlD,SAAgB,eAAe,CAAC,OAAgB,EAAE,IAA6B,EAAE,IAAY,EAAE,IAAoB;IAC/G,MAAM,SAAS,GAA2B,OAAO,CAAC,KAAK,CAAC;IACxD,IAAI,CAAC,CAAC,SAAS,YAAY,2BAAmB,CAAC,EAAE;QAC7C,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;KACrD;IAED,MAAM,SAAS,GAAG,IAAI,2BAAmB,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;IACjE,OAAO,CAAC,kBAAkB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,EAAE,GAAG,EAAE;QACzD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAkC,EAAE,EAAE;YAC3D,2BAAe,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,SAAS,CAAC,IAAI,GAAG,oBAAoB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAErD,IAAI,SAAS,CAAC,aAAa,EAAE;YACzB,SAAS,CAAC,aAAa,GAAG,+BAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC7E;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,OAAO,CAAC,qBAAS,CAAC,sBAAsB,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACnE,OAAO,SAAS,CAAC;AACrB,CAAC;AAtBD,0CAsBC;AASD,SAAS,oBAAoB,CAAC,OAAgB,EAAE,IAA6B;IACzE,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,aAAa,IAAI,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,UAAU,CAAC,cAAc,EAAE;QACrF,IAAI;YACA,MAAM,SAAS,GAAG,OAAO,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;YAE5D,IAAI,CAAC,SAAS,EAAE;gBACZ,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;aAC7D;YACD,OAAO,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC,CAAC;SACzG;QAAC,OAAO,KAAK,EAAE,GAAE;KACrB;IAED,OAAO,OAAO,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC;AACrE,CAAC","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { ReflectionKind, SignatureReflection, ContainerReflection, DeclarationReflection, Type } from '../../models/index';\r\nimport { Context } from '../context';\r\nimport { Converter } from '../converter';\r\nimport { createParameter } from './parameter';\r\nimport { createReferenceType } from './reference';\r\n\r\n/**\r\n * Create a new signature reflection from the given node.\r\n *\r\n * @param context  The context object describing the current state the converter is in.\r\n * @param node  The TypeScript node containing the signature declaration that should be reflected.\r\n * @param name  The name of the function or method this signature belongs to.\r\n * @param kind  The desired kind of the reflection.\r\n * @returns The newly created signature reflection describing the given node.\r\n */\r\nexport function createSignature(context: Context, node: ts.SignatureDeclaration, name: string, kind: ReflectionKind): SignatureReflection {\r\n    const container = <DeclarationReflection> context.scope;\r\n    if (!(container instanceof ContainerReflection)) {\r\n        throw new Error('Expected container reflection.');\r\n    }\r\n\r\n    const signature = new SignatureReflection(name, kind, container);\r\n    context.registerReflection(signature, node);\r\n    context.withScope(signature, node.typeParameters, true, () => {\r\n        node.parameters.forEach((parameter: ts.ParameterDeclaration) => {\r\n            createParameter(context, parameter);\r\n        });\r\n\r\n        signature.type = extractSignatureType(context, node);\r\n\r\n        if (container.inheritedFrom) {\r\n            signature.inheritedFrom = createReferenceType(context, node.symbol, true);\r\n        }\r\n    });\r\n\r\n    context.trigger(Converter.EVENT_CREATE_SIGNATURE, signature, node);\r\n    return signature;\r\n}\r\n\r\n/**\r\n * Extract the return type of the given signature declaration.\r\n *\r\n * @param context  The context object describing the current state the converter is in.\r\n * @param node  The signature declaration whose return type should be determined.\r\n * @returns The return type reflection of the given signature.\r\n */\r\nfunction extractSignatureType(context: Context, node: ts.SignatureDeclaration): Type | undefined {\r\n    const checker = context.checker;\r\n    if (node.kind & ts.SyntaxKind.CallSignature || node.kind & ts.SyntaxKind.CallExpression) {\r\n        try {\r\n            const signature = checker.getSignatureFromDeclaration(node);\r\n            // This is essentially what checker.getReturnTypeOfSignature will do, but doing it ourselves avoids type errors.\r\n            if (!signature) {\r\n                throw new Error('Failed to retrieve signature for node.');\r\n            }\r\n            return context.converter.convertType(context, node.type, checker.getReturnTypeOfSignature(signature));\r\n        } catch (error) {}\r\n    }\r\n\r\n    return context.converter.convertType(context, node.type || node);\r\n}\r\n"]}