{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { ReflectionKind, ReflectionFlag, ContainerReflection, DeclarationReflection } from '../../models/index';\r\nimport { Context } from '../context';\r\nimport { Converter } from '../converter';\r\nimport { createReferenceType } from './reference';\r\n\r\n/**\r\n * List of reflection kinds that never should be static.\r\n */\r\nconst nonStaticKinds = [\r\n    ReflectionKind.Class,\r\n    ReflectionKind.Interface,\r\n    ReflectionKind.Module\r\n];\r\n\r\n/**\r\n * List of ts kinds leading to none static merge.\r\n */\r\nconst nonStaticMergeKinds = [\r\n    ts.SyntaxKind.ClassDeclaration,\r\n    ts.SyntaxKind.InterfaceDeclaration\r\n];\r\n\r\n/**\r\n * Create a declaration reflection from the given TypeScript node.\r\n *\r\n * @param context  The context object describing the current state the converter is in. The\r\n *   scope of the context will be the parent of the generated reflection.\r\n * @param node  The TypeScript node that should be converted to a reflection.\r\n * @param kind  The desired kind of the reflection.\r\n * @param name  The desired name of the reflection.\r\n * @returns The resulting reflection or undefined if an error is encountered.\r\n */\r\nexport function createDeclaration(context: Context, node: ts.Declaration, kind: ReflectionKind, name?: string): DeclarationReflection | undefined {\r\n    if (!(context.scope instanceof ContainerReflection)) {\r\n        throw new Error('Expected container reflection.');\r\n    }\r\n    const container = context.scope;\r\n\r\n    // Ensure we have a name for the reflection\r\n    if (!name) {\r\n        if (node.localSymbol) {\r\n            name = node.localSymbol.name;\r\n        } else if (node.symbol) {\r\n            name = node.symbol.name;\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    const modifiers = ts.getCombinedModifierFlags(node);\r\n\r\n    // Test whether the node is exported\r\n    let isExported: boolean;\r\n    if (container.kindOf([ReflectionKind.Module, ReflectionKind.ExternalModule])) {\r\n        isExported = false; // Don't inherit exported state in modules and namespaces\r\n    } else {\r\n        isExported = container.flags.isExported;\r\n    }\r\n\r\n    if (kind === ReflectionKind.ExternalModule) {\r\n        isExported = true; // Always mark external modules as exported\r\n    } else if (node.parent && node.parent.kind === ts.SyntaxKind.VariableDeclarationList) {\r\n        const parentModifiers = ts.getCombinedModifierFlags(node.parent.parent as ts.Declaration);\r\n        isExported = isExported || !!(parentModifiers & ts.ModifierFlags.Export);\r\n    } else {\r\n        isExported = isExported || !!(modifiers & ts.ModifierFlags.Export);\r\n    }\r\n\r\n    if (!isExported && context.converter.excludeNotExported) {\r\n        return;\r\n    }\r\n\r\n    // Test whether the node is private, when inheriting ignore private members\r\n    const isPrivate = !!(modifiers & ts.ModifierFlags.Private);\r\n    if (context.isInherit && isPrivate) {\r\n        return;\r\n    }\r\n\r\n    // Test whether the node is static, when merging a module to a class make the node static\r\n    let isConstructorProperty = false;\r\n    let isStatic = false;\r\n    if (nonStaticKinds.indexOf(kind) === -1) {\r\n        isStatic = !!(modifiers & ts.ModifierFlags.Static);\r\n        if (container.kind === ReflectionKind.Class) {\r\n            if (node.parent && node.parent.kind === ts.SyntaxKind.Constructor) {\r\n                isConstructorProperty = true;\r\n            } else if (!node.parent || nonStaticMergeKinds.indexOf(node.parent.kind) === -1) {\r\n                isStatic = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check if we already have a child with the same name and static flag\r\n    let child: DeclarationReflection | undefined;\r\n    const children = container.children = container.children || [];\r\n    children.forEach((n: DeclarationReflection) => {\r\n        if (n.name === name && n.flags.isStatic === isStatic) {\r\n            child = n;\r\n        }\r\n    });\r\n\r\n    if (!child) {\r\n        // Child does not exist, create a new reflection\r\n        child = new DeclarationReflection(name, kind, container);\r\n        child.setFlag(ReflectionFlag.Static, isStatic);\r\n        child.setFlag(ReflectionFlag.Private, isPrivate);\r\n        child.setFlag(ReflectionFlag.ConstructorProperty, isConstructorProperty);\r\n        child.setFlag(ReflectionFlag.Exported,  isExported);\r\n        child = setupDeclaration(context, child, node);\r\n\r\n        if (child) {\r\n            children.push(child);\r\n            context.registerReflection(child, node);\r\n        }\r\n    } else {\r\n        // Merge the existent reflection with the given node\r\n        child = mergeDeclarations(context, child, node, kind);\r\n    }\r\n\r\n    // If we have a reflection, trigger the corresponding event\r\n    if (child) {\r\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, child, node);\r\n    }\r\n\r\n    return child;\r\n}\r\n\r\n/**\r\n * Setup a newly created declaration reflection.\r\n *\r\n * @param context  The context object describing the current state the converter is in.\r\n * @param reflection  The newly created blank reflection.\r\n * @param node  The TypeScript node whose properties should be applies to the given reflection.\r\n * @returns The reflection populated with the values of the given node.\r\n */\r\nfunction setupDeclaration(context: Context, reflection: DeclarationReflection, node: ts.Declaration) {\r\n    const modifiers = ts.getCombinedModifierFlags(node);\r\n\r\n    reflection.setFlag(ReflectionFlag.External,  context.isExternal);\r\n    reflection.setFlag(ReflectionFlag.Protected, !!(modifiers & ts.ModifierFlags.Protected));\r\n    reflection.setFlag(ReflectionFlag.Public,    !!(modifiers & ts.ModifierFlags.Public));\r\n    reflection.setFlag(ReflectionFlag.Optional,  !!(node['questionToken']));\r\n\r\n    if (\r\n        context.isInherit &&\r\n        (node.parent === context.inheritParent || reflection.flags.isConstructorProperty)\r\n    ) {\r\n        if (!reflection.inheritedFrom) {\r\n            reflection.inheritedFrom = createReferenceType(context, node.symbol, true);\r\n            reflection.getAllSignatures().forEach((signature) => {\r\n                signature.inheritedFrom = createReferenceType(context, node.symbol, true);\r\n            });\r\n        }\r\n    }\r\n\r\n    return reflection;\r\n}\r\n\r\n/**\r\n * Merge the properties of the given TypeScript node with the pre existent reflection.\r\n *\r\n * @param context  The context object describing the current state the converter is in.\r\n * @param reflection  The pre existent reflection.\r\n * @param node  The TypeScript node whose properties should be merged with the given reflection.\r\n * @param kind  The desired kind of the reflection.\r\n * @returns The reflection merged with the values of the given node or NULL if the merge is invalid.\r\n */\r\nfunction mergeDeclarations(context: Context, reflection: DeclarationReflection, node: ts.Node, kind: ReflectionKind) {\r\n    if (reflection.kind !== kind) {\r\n        const weights = [ReflectionKind.Module, ReflectionKind.Enum, ReflectionKind.Class];\r\n        const kindWeight = weights.indexOf(kind);\r\n        const childKindWeight = weights.indexOf(reflection.kind);\r\n        if (kindWeight > childKindWeight) {\r\n            reflection.kind = kind;\r\n        }\r\n    }\r\n\r\n    if (\r\n        context.isInherit &&\r\n        (context.inherited || []).indexOf(reflection.name) !== -1 &&\r\n        (node.parent === context.inheritParent || reflection.flags.isConstructorProperty)\r\n    ) {\r\n        if (!reflection.overwrites) {\r\n            reflection.overwrites = createReferenceType(context, node.symbol, true);\r\n            reflection.getAllSignatures().forEach((signature) => {\r\n                signature.overwrites = createReferenceType(context, node.symbol, true);\r\n            });\r\n        }\r\n        return;\r\n    }\r\n\r\n    return reflection;\r\n}\r\n"]}