{"version":3,"file":"converter.js","sourceRoot":"","sources":["../../../src/lib/converter/converter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\r\nimport * as _ts from '../ts-internal';\r\nimport * as _ from 'lodash';\r\n\r\nimport { Application } from '../application';\r\nimport { ParameterType } from '../utils/options/declaration';\r\nimport { Reflection, Type, ProjectReflection } from '../models/index';\r\nimport { Context } from './context';\r\nimport { ConverterComponent, ConverterNodeComponent, ConverterTypeComponent, TypeTypeConverter, TypeNodeConverter } from './components';\r\nimport { CompilerHost } from './utils/compiler-host';\r\nimport { Component, Option, ChildableComponent, ComponentClass } from '../utils/component';\r\nimport { normalizePath } from '../utils/fs';\r\n\r\n/**\r\n * Result structure of the [[Converter.convert]] method.\r\n */\r\nexport interface ConverterResult {\r\n    /**\r\n     * An array containing all errors generated by the TypeScript compiler.\r\n     */\r\n    errors: ReadonlyArray<ts.Diagnostic>;\r\n\r\n    /**\r\n     * The resulting project reflection.\r\n     */\r\n    project: ProjectReflection;\r\n}\r\n\r\n/**\r\n * Compiles source files using TypeScript and converts compiler symbols to reflections.\r\n */\r\n@Component({name: 'converter', internal: true, childClass: ConverterComponent})\r\nexport class Converter extends ChildableComponent<Application, ConverterComponent> {\r\n    /**\r\n     * The human readable name of the project. Used within the templates to set the title of the document.\r\n     */\r\n    @Option({\r\n        name: 'name',\r\n        help: 'Set the name of the project that will be used in the header of the template.'\r\n    })\r\n    name!: string;\r\n\r\n    @Option({\r\n        name: 'externalPattern',\r\n        help: 'Define a pattern for files that should be considered being external.'\r\n    })\r\n    externalPattern!: string;\r\n\r\n    @Option({\r\n        name: 'includeDeclarations',\r\n        help: 'Turn on parsing of .d.ts declaration files.',\r\n        type: ParameterType.Boolean\r\n    })\r\n    includeDeclarations!: boolean;\r\n\r\n    @Option({\r\n        name: 'excludeExternals',\r\n        help: 'Prevent externally resolved TypeScript files from being documented.',\r\n        type: ParameterType.Boolean\r\n    })\r\n    excludeExternals!: boolean;\r\n\r\n    @Option({\r\n        name: 'excludeNotExported',\r\n        help: 'Prevent symbols that are not exported from being documented.',\r\n        type: ParameterType.Boolean\r\n    })\r\n    excludeNotExported!: boolean;\r\n\r\n    @Option({\r\n        name: 'excludePrivate',\r\n        help: 'Ignores private variables and methods',\r\n        type: ParameterType.Boolean\r\n    })\r\n    excludePrivate!: boolean;\r\n\r\n    @Option({\r\n        name: 'excludeProtected',\r\n        help: 'Ignores protected variables and methods',\r\n        type: ParameterType.Boolean\r\n    })\r\n    excludeProtected!: boolean;\r\n\r\n    /**\r\n     * Defined in the initialize method\r\n     */\r\n    private compilerHost!: CompilerHost;\r\n\r\n    /**\r\n     * Defined in the initialize method\r\n     */\r\n    private nodeConverters!: {[syntaxKind: number]: ConverterNodeComponent<ts.Node>};\r\n\r\n    /**\r\n     * Defined in the initialize method\r\n     */\r\n    private typeNodeConverters!: TypeNodeConverter<ts.Type, ts.Node>[];\r\n\r\n    /**\r\n     * Defined in the initialize method\r\n     */\r\n    private typeTypeConverters!: TypeTypeConverter<ts.Type>[];\r\n\r\n    /**\r\n     * General events\r\n     */\r\n\r\n    /**\r\n     * Triggered when the converter begins converting a project.\r\n     * The listener should implement [[IConverterCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_BEGIN = 'begin';\r\n\r\n    /**\r\n     * Triggered when the converter has finished converting a project.\r\n     * The listener should implement [[IConverterCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_END = 'end';\r\n\r\n    /**\r\n     * Factory events\r\n     */\r\n\r\n    /**\r\n     * Triggered when the converter begins converting a source file.\r\n     * The listener should implement [[IConverterNodeCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_FILE_BEGIN = 'fileBegin';\r\n\r\n    /**\r\n     * Triggered when the converter has created a declaration reflection.\r\n     * The listener should implement [[IConverterNodeCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_CREATE_DECLARATION = 'createDeclaration';\r\n\r\n    /**\r\n     * Triggered when the converter has created a signature reflection.\r\n     * The listener should implement [[IConverterNodeCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_CREATE_SIGNATURE = 'createSignature';\r\n\r\n    /**\r\n     * Triggered when the converter has created a parameter reflection.\r\n     * The listener should implement [[IConverterNodeCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_CREATE_PARAMETER = 'createParameter';\r\n\r\n    /**\r\n     * Triggered when the converter has created a type parameter reflection.\r\n     * The listener should implement [[IConverterNodeCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_CREATE_TYPE_PARAMETER = 'createTypeParameter';\r\n\r\n    /**\r\n     * Triggered when the converter has found a function implementation.\r\n     * The listener should implement [[IConverterNodeCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_FUNCTION_IMPLEMENTATION = 'functionImplementation';\r\n\r\n    /**\r\n     * Resolve events\r\n     */\r\n\r\n    /**\r\n     * Triggered when the converter begins resolving a project.\r\n     * The listener should implement [[IConverterCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_RESOLVE_BEGIN = 'resolveBegin';\r\n\r\n    /**\r\n     * Triggered when the converter resolves a reflection.\r\n     * The listener should implement [[IConverterResolveCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_RESOLVE = 'resolveReflection';\r\n\r\n    /**\r\n     * Triggered when the converter has finished resolving a project.\r\n     * The listener should implement [[IConverterCallback]].\r\n     * @event\r\n     */\r\n    static EVENT_RESOLVE_END = 'resolveEnd';\r\n\r\n    /**\r\n     * Create a new Converter instance.\r\n     *\r\n     * @param application  The application instance this converter relies on. The application\r\n     *   must expose the settings that should be used and serves as a global logging endpoint.\r\n     */\r\n    initialize() {\r\n        this.compilerHost = new CompilerHost(this);\r\n        this.nodeConverters = {};\r\n        this.typeTypeConverters = [];\r\n        this.typeNodeConverters = [];\r\n    }\r\n\r\n    addComponent<T extends ConverterComponent & Component>(name: string, componentClass: T | ComponentClass<T>): T {\r\n        const component = super.addComponent(name, componentClass);\r\n        if (component instanceof ConverterNodeComponent) {\r\n            this.addNodeConverter(component);\r\n        } else if (component instanceof ConverterTypeComponent) {\r\n            this.addTypeConverter(component);\r\n        }\r\n\r\n        return component;\r\n    }\r\n\r\n    private addNodeConverter(converter: ConverterNodeComponent<any>) {\r\n        for (let supports of converter.supports) {\r\n            this.nodeConverters[supports] = converter;\r\n        }\r\n    }\r\n\r\n    private addTypeConverter(converter: ConverterTypeComponent) {\r\n        if ('supportsNode' in converter && 'convertNode' in converter) {\r\n            this.typeNodeConverters.push(<TypeNodeConverter<any, any>> converter);\r\n            this.typeNodeConverters.sort((a, b) => (b.priority || 0) - (a.priority || 0));\r\n        }\r\n\r\n        if ('supportsType' in converter && 'convertType' in converter) {\r\n            this.typeTypeConverters.push(<TypeTypeConverter<any>> converter);\r\n            this.typeTypeConverters.sort((a, b) => (b.priority || 0) - (a.priority || 0));\r\n        }\r\n    }\r\n\r\n    removeComponent(name: string): ConverterComponent | undefined {\r\n        const component = super.removeComponent(name);\r\n        if (component instanceof ConverterNodeComponent) {\r\n            this.removeNodeConverter(component);\r\n        } else if (component instanceof ConverterTypeComponent) {\r\n            this.removeTypeConverter(component);\r\n        }\r\n\r\n        return component;\r\n    }\r\n\r\n    private removeNodeConverter(converter: ConverterNodeComponent<any>) {\r\n        const converters = this.nodeConverters;\r\n        const keys = _.keys(this.nodeConverters);\r\n        for (let key of keys) {\r\n            if (converters[key] === converter) {\r\n                delete converters[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeTypeConverter(converter: ConverterTypeComponent) {\r\n        const typeIndex = this.typeTypeConverters.indexOf(<any> converter);\r\n        if (typeIndex !== -1) {\r\n            this.typeTypeConverters.splice(typeIndex, 1);\r\n        }\r\n\r\n        const nodeIndex = this.typeNodeConverters.indexOf(<any> converter);\r\n        if (nodeIndex !== -1) {\r\n            this.typeNodeConverters.splice(nodeIndex, 1);\r\n        }\r\n    }\r\n\r\n    removeAllComponents() {\r\n        super.removeAllComponents();\r\n\r\n        this.nodeConverters = {};\r\n        this.typeTypeConverters = [];\r\n        this.typeNodeConverters = [];\r\n    }\r\n\r\n    /**\r\n     * Compile the given source files and create a project reflection for them.\r\n     *\r\n     * @param fileNames  Array of the file names that should be compiled.\r\n     */\r\n    convert(fileNames: string[]): ConverterResult {\r\n        for (let i = 0, c = fileNames.length; i < c; i++) {\r\n            fileNames[i] = normalizePath(_ts.normalizeSlashes(fileNames[i]));\r\n        }\r\n\r\n        const program = ts.createProgram(fileNames, this.application.options.getCompilerOptions(), this.compilerHost);\r\n        const checker = program.getTypeChecker();\r\n        const context = new Context(this, fileNames, checker, program);\r\n\r\n        this.trigger(Converter.EVENT_BEGIN, context);\r\n\r\n        const errors = this.compile(context);\r\n        const project = this.resolve(context);\r\n\r\n        this.trigger(Converter.EVENT_END, context);\r\n\r\n        return {\r\n            errors: errors,\r\n            project: project\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Analyze the given node and create a suitable reflection.\r\n     *\r\n     * This function checks the kind of the node and delegates to the matching function implementation.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node     The compiler node that should be analyzed.\r\n     * @return The resulting reflection or undefined.\r\n     */\r\n    convertNode(context: Context, node: ts.Node): Reflection | undefined {\r\n        if (context.visitStack.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        const oldVisitStack = context.visitStack;\r\n        context.visitStack = oldVisitStack.slice();\r\n        context.visitStack.push(node);\r\n\r\n        let result: Reflection | undefined;\r\n        if (node.kind in this.nodeConverters) {\r\n            result = this.nodeConverters[node.kind].convert(context, node);\r\n        }\r\n\r\n        context.visitStack = oldVisitStack;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert the given TypeScript type into its TypeDoc type reflection.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node  The node whose type should be reflected.\r\n     * @param type  The type of the node if already known.\r\n     * @returns The TypeDoc type reflection representing the given node and type.\r\n     */\r\n    convertType(context: Context, node?: ts.Node, type?: ts.Type): Type | undefined {\r\n        // Run all node based type conversions\r\n        if (node) {\r\n            type = type || context.getTypeAtLocation(node);\r\n\r\n            for (let converter of this.typeNodeConverters) {\r\n                if (converter.supportsNode(context, node, type)) {\r\n                    return converter.convertNode(context, node, type);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Run all type based type conversions\r\n        if (type) {\r\n            for (let converter of this.typeTypeConverters) {\r\n                if (converter.supportsType(context, type)) {\r\n                    return converter.convertType(context, type);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to convert multiple types at once, filtering out types which fail to convert.\r\n     *\r\n     * @param context\r\n     * @param nodes\r\n     */\r\n    convertTypes(context: Context, nodes: ReadonlyArray<ts.Node> = [], types: ReadonlyArray<ts.Type> = []): Type[] {\r\n        const result: Type[] = [];\r\n        _.zip(nodes, types).forEach(([node, type]) => {\r\n            const converted = this.convertType(context, node, type);\r\n            if (converted) {\r\n                result.push(converted);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Compile the files within the given context and convert the compiler symbols to reflections.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @returns An array containing all errors generated by the TypeScript compiler.\r\n     */\r\n    private compile(context: Context): ReadonlyArray<ts.Diagnostic> {\r\n        const program = context.program;\r\n\r\n        program.getSourceFiles().forEach((sourceFile) => {\r\n            this.convertNode(context, sourceFile);\r\n        });\r\n\r\n        let diagnostics = program.getOptionsDiagnostics();\r\n        if (diagnostics.length) {\r\n            return diagnostics;\r\n        }\r\n\r\n        diagnostics = program.getSyntacticDiagnostics();\r\n        if (diagnostics.length) {\r\n            return diagnostics;\r\n        }\r\n\r\n        diagnostics = program.getGlobalDiagnostics();\r\n        if (diagnostics.length) {\r\n            return diagnostics;\r\n        }\r\n\r\n        diagnostics = program.getSemanticDiagnostics();\r\n        if (diagnostics.length) {\r\n            return diagnostics;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Resolve the project within the given context.\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @returns The final project reflection.\r\n     */\r\n    private resolve(context: Context): ProjectReflection {\r\n        this.trigger(Converter.EVENT_RESOLVE_BEGIN, context);\r\n        const project = context.project;\r\n\r\n        for (let id in project.reflections) {\r\n            if (!project.reflections.hasOwnProperty(id)) {\r\n                continue;\r\n            }\r\n            this.trigger(Converter.EVENT_RESOLVE, context, project.reflections[id]);\r\n        }\r\n\r\n        this.trigger(Converter.EVENT_RESOLVE_END, context);\r\n        return project;\r\n    }\r\n\r\n    /**\r\n     * Return the basename of the default library that should be used.\r\n     *\r\n     * @returns The basename of the default library.\r\n     */\r\n    getDefaultLib(): string {\r\n        return ts.getDefaultLibFileName(this.application.options.getCompilerOptions());\r\n    }\r\n}\r\n"]}