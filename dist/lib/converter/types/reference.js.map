{"version":3,"file":"reference.js","sourceRoot":"","sources":["../../../../src/lib/converter/types/reference.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { Type, IntrinsicType, ReflectionType } from '../../models/types/index';\r\nimport { ReflectionKind, DeclarationReflection } from '../../models/reflections/index';\r\nimport { createReferenceType } from '../factories/index';\r\nimport { Component, ConverterTypeComponent, TypeNodeConverter } from '../components';\r\nimport { Context } from '../context';\r\nimport { Converter } from '../converter';\r\n\r\n@Component({name: 'type:reference'})\r\nexport class ReferenceConverter extends ConverterTypeComponent implements TypeNodeConverter<ts.TypeReference, ts.TypeReferenceNode> {\r\n    /**\r\n     * The priority this converter should be executed with.\r\n     * A higher priority means the converter will be applied earlier.\r\n     */\r\n    priority = -50;\r\n\r\n    /**\r\n     * Test whether this converter can handle the given TypeScript node.\r\n     */\r\n    supportsNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): boolean {\r\n        return !!(type.flags & ts.TypeFlags.Object);\r\n    }\r\n\r\n    /**\r\n     * Test whether this converter can handle the given TypeScript type.\r\n     */\r\n    supportsType(context: Context, type: ts.TypeReference): boolean {\r\n        return !!(type.flags & ts.TypeFlags.Object);\r\n    }\r\n\r\n    /**\r\n     * Convert the type reference node to its type reflection.\r\n     *\r\n     * This is a node based converter, see [[convertTypeReferenceType]] for the type equivalent.\r\n     *\r\n     * ```\r\n     * class SomeClass { }\r\n     * let someValue: SomeClass;\r\n     * ```\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param node  The type reference node that should be converted.\r\n     * @param type  The type of the type reference node.\r\n     * @returns The type reflection representing the given reference node.\r\n     */\r\n    convertNode(context: Context, node: ts.TypeReferenceNode, type: ts.TypeReference): Type | undefined {\r\n        if (!type.symbol) {\r\n            return new IntrinsicType('Object');\r\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\r\n            return this.convertLiteral(context, type.symbol, node);\r\n        }\r\n\r\n        const result = createReferenceType(context, type.symbol);\r\n        if (result && node.typeArguments) {\r\n            result.typeArguments = this.owner.convertTypes(context, node.typeArguments);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert the given type reference to its type reflection.\r\n     *\r\n     * This is a type based converter, see [[convertTypeReference]] for the node equivalent.\r\n     *\r\n     * ```\r\n     * class SomeClass { }\r\n     * let someValue: SomeClass;\r\n     * ```\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param type  The type reference that should be converted.\r\n     * @returns The type reflection representing the given type reference.\r\n     */\r\n    convertType(context: Context, type: ts.TypeReference): Type | undefined {\r\n        if (!type.symbol) {\r\n            return new IntrinsicType('Object');\r\n        } else if (type.symbol.declarations && (type.symbol.flags & ts.SymbolFlags.TypeLiteral || type.symbol.flags & ts.SymbolFlags.ObjectLiteral)) {\r\n            return this.convertLiteral(context, type.symbol);\r\n        }\r\n\r\n        const result = createReferenceType(context, type.symbol);\r\n        if (result && type.typeArguments) {\r\n            result.typeArguments = this.owner.convertTypes(context, undefined, type.typeArguments);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a type literal reflection.\r\n     *\r\n     * This is a utility function used by [[convertTypeReferenceNode]] and\r\n     * [[convertTypeReferenceType]] when encountering an object or type literal.\r\n     *\r\n     * A type literal is explicitly set:\r\n     * ```\r\n     * let someValue: {a: string; b: number;};\r\n     * ```\r\n     *\r\n     * An object literal types are usually reflected by the TypeScript compiler:\r\n     * ```\r\n     * function someFunction() { return {a: 'Test', b: 1024}; }\r\n     * ```\r\n     *\r\n     * @param context  The context object describing the current state the converter is in.\r\n     * @param symbol  The symbol describing the type literal.\r\n     * @param node  If known the node which produced the type literal. Type literals that are\r\n     *   implicitly generated by TypeScript won't have a corresponding node.\r\n     * @returns A type reflection representing the given type literal.\r\n     */\r\n    private convertLiteral(context: Context, symbol: ts.Symbol, node?: ts.Node): Type | undefined {\r\n        for (let declaration of symbol.declarations) {\r\n            if (context.visitStack.indexOf(declaration) !== -1) {\r\n                if (declaration.kind === ts.SyntaxKind.TypeLiteral ||\r\n                        declaration.kind === ts.SyntaxKind.ObjectLiteralExpression) {\r\n                    // TODO: Check if this type assertion is safe and document.\r\n                    return createReferenceType(context, declaration.parent.symbol!);\r\n                } else {\r\n                    // TODO: Check if this type assertion is safe and document.\r\n                    return createReferenceType(context, declaration.symbol!);\r\n                }\r\n            }\r\n        }\r\n\r\n        const declaration = new DeclarationReflection('__type', ReflectionKind.TypeLiteral, context.scope);\r\n\r\n        context.registerReflection(declaration, undefined, symbol);\r\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, declaration, node);\r\n        context.withScope(declaration, () => {\r\n            symbol.declarations.forEach((node) => {\r\n                this.owner.convertNode(context, node);\r\n            });\r\n        });\r\n\r\n        return new ReflectionType(declaration);\r\n    }\r\n}\r\n"]}