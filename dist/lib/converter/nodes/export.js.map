{"version":3,"file":"export.js","sourceRoot":"","sources":["../../../../src/lib/converter/nodes/export.ts"],"names":[],"mappings":";;;;;;;;AAAA,iCAAiC;AAEjC,8CAAuF;AAEvF,8CAAkE;AAGlE,IAAa,eAAe,GAA5B,MAAa,eAAgB,SAAQ,mCAA2C;IADhF;;QAKI,aAAQ,GAAoB;YACxB,EAAE,CAAC,UAAU,CAAC,gBAAgB;SACjC,CAAC;IAyCN,CAAC;IAvCG,OAAO,CAAC,OAAgB,EAAE,IAAyB;QAC/C,IAAI,MAA6B,CAAC;QAGlC,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,WAAW,CAAC,KAAK,EAAE;YACpF,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC1D;aAAM;YACH,IAAI,IAAI,GAAG,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC;SAC3C;QACD,IAAI,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE;YAC/B,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAChC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;gBACxC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE;oBACrB,OAAO;iBACV;gBACD,MAAM,EAAE,GAAG,OAAO,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,CAAE,CAAC,CAAC;gBAC3E,IAAI,CAAC,EAAE,EAAE;oBACL,OAAO;iBACV;gBAED,MAAM,UAAU,GAAG,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;gBAC3C,IAAI,IAAI,CAAC,cAAc,IAAI,UAAU,YAAY,6BAAqB,EAAE;oBACpE,UAAU,CAAC,OAAO,CAAC,sBAAc,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;iBAC7D;gBACD,cAAc,CAAC,UAAU,CAAC,CAAC;YAC/B,CAAC,CAAC,CAAC;SACN;QAED,SAAS,cAAc,CAAC,UAAsB;YAC1C,IAAI,UAAU,YAAY,6BAAqB,EAAE;gBAC7C,UAAU,CAAC,OAAO,CAAC,sBAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;aACrD;YAED,UAAU,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;QACxC,CAAC;QAED,OAAO,OAAO,CAAC,KAAK,CAAC;IACzB,CAAC;CACJ,CAAA;AA/CY,eAAe;IAD3B,sBAAS,CAAC,EAAC,IAAI,EAAE,aAAa,EAAC,CAAC;GACpB,eAAe,CA+C3B;AA/CY,0CAAe","sourcesContent":["import * as ts from 'typescript';\r\n\r\nimport { Reflection, ReflectionFlag, DeclarationReflection } from '../../models/index';\r\nimport { Context } from '../context';\r\nimport { Component, ConverterNodeComponent } from '../components';\r\n\r\n@Component({name: 'node:export'})\r\nexport class ExportConverter extends ConverterNodeComponent<ts.ExportAssignment> {\r\n    /**\r\n     * List of supported TypeScript syntax kinds.\r\n     */\r\n    supports: ts.SyntaxKind[] = [\r\n        ts.SyntaxKind.ExportAssignment\r\n    ];\r\n\r\n    convert(context: Context, node: ts.ExportAssignment): Reflection {\r\n        let symbol: ts.Symbol | undefined;\r\n\r\n        // default export\r\n        if (node.symbol && (node.symbol.flags & ts.SymbolFlags.Alias) === ts.SymbolFlags.Alias) {\r\n            symbol = context.checker.getAliasedSymbol(node.symbol);\r\n        } else {\r\n            let type = context.getTypeAtLocation(node.expression);\r\n            symbol = type ? type.symbol : undefined;\r\n        }\r\n        if (symbol && symbol.declarations) {\r\n            const project = context.project;\r\n            symbol.declarations.forEach((declaration) => {\r\n                if (!declaration.symbol) {\r\n                    return;\r\n                }\r\n                const id = project.symbolMapping[context.getSymbolID(declaration.symbol)!];\r\n                if (!id) {\r\n                    return;\r\n                }\r\n\r\n                const reflection = project.reflections[id];\r\n                if (node.isExportEquals && reflection instanceof DeclarationReflection) {\r\n                    reflection.setFlag(ReflectionFlag.ExportAssignment, true);\r\n                }\r\n                markAsExported(reflection);\r\n            });\r\n        }\r\n\r\n        function markAsExported(reflection: Reflection) {\r\n            if (reflection instanceof DeclarationReflection) {\r\n                reflection.setFlag(ReflectionFlag.Exported, true);\r\n            }\r\n\r\n            reflection.traverse(markAsExported);\r\n        }\r\n\r\n        return context.scope;\r\n    }\r\n}\r\n"]}